# TrufosExploit
This is exploit which leverages pool overflow in one of Bitdefender's kernel drivers - Trufos.sys to disable protected process light of particular process. I wrote this exploit in order to learn more about windows kernel exploitation. According to bitdefender, this is not security vulnerability since “if you have administrative rights, you can do anything to a system”, but it can still be used in BYOVD attacks. I mainly use this exploit when I want to debug some protected process, sometimes its just easier than using with kernel debugger.
# Usage:
TrufosExploit.exe -InstallDriver -DisableProtection (ProcessId)

-InstallDriver is optional parameter and it should be used in case of Trufos.sys driver is not installed. 

However this exploit is not perfect yet. Here are few known issues which needs to be fixed:
- Lack of option to uninstall driver
- Improve heap spraying technique in SetupArbitraryWrite function. Sometimes there is a case when two valid DATA_QUEUE_ENTRY objects are not adjacent and if the first one is overflowed to achieve relative read and if the second is already freed, this later makes bsod occur. With current spraying technique, the exploit will be executed with really high chance, but it always could be better.
- Fix corrupted DATA_QUEUE_ENTRIES, because in current state of this exploit, it throws bsod during next system shutdown. That’s reason why it stays keep running in the background, to not free corrupted data queue entries.

This exploit works on newest Windows 11 and Windows 10 versions. Moreover it finds offsets automatically, so updating offsets of most internal structures shouldn't be required when needed to run on other windows version.

# Root cause of that “vulnerability”
This vulnerability lies in function responsible for parsing input buffer in function message notify callback of filter communication port. After connecting to filter communication port, we can send messages to the driver which will be parsed in message notify callback, which is passed as a parameter to FltCreateCommunicationPort. To communicate with driver, we can use FilterSendMessage function. 
Here is decompilation of MessageNotifyCallback:

![1_2](https://github.com/Amunius/TrufosExploit/assets/81387886/427757ad-dcac-4af4-ae1c-ca71a6b41d6f)

Firstly it checks whether input and output buffers are valid. Next it checks if byte at offset 0xC of PortCookie is zero, if so it checks if 32 bit integer in input buffer is set to 0x12355321 and if it isn’t then it returns 0xC0000001. Assuming that it is ntstatus, then it means STATUS_UNSUCCESSFUL. If the integer in input buffer is set to that magic value, then it sets that byte which was checked earlier to 1. After it is set to 1, every time when send message to that communication port it will call FUN_140067D90. So we need to just send message with 0x12355321 in input buffer.

![2_2](https://github.com/Amunius/TrufosExploit/assets/81387886/aa1a7c92-bb0d-4c73-b999-0b74598d3ff2)

This function does some additional checks, which are irrelevant since they are always true. After these checks, it calls some function pointer from port cookie. I named this function ParseMessage and it is actually responsible for parsing input buffer. First what that function does is check if at offset 0x140 of SomeObject is set to 0. I’m not quite sure what is SomeObject, it is get from some really complex function, which I didn’t fully reversed, but I didn’t had to since knowledge about this object is irrelevant to further exploitation. 

![3_2](https://github.com/Amunius/TrufosExploit/assets/81387886/3f84512b-4d64-485b-bd4e-799e5a7530ac)

So if it is set to zero (it is 0 by default), then it does some additional checks. Again to pass all checks all we need to do is to pass some magic values in input buffer.

![4](https://github.com/Amunius/TrufosExploit/assets/81387886/092dc6e6-ed03-4e18-908f-9f60babc2ecf)

After sending second message with these magic values, all previous checks are gone and trufos.sys will properly parse every next message. At that point, the first 32 bit integer in input buffer determines which dispatch function will parse input buffer. There are dozens of these functions and there are a lot of code to reverse. In this exploit’s case, the first integer should be set to 0xC in order to call a function where is pool overflow. But before I will describe details about this overflow, I need to explain how input buffer is structured. I have drawn how input buffer looks like in memory: 

![5](https://github.com/Amunius/TrufosExploit/assets/81387886/e4e4fbe2-2df5-46da-9495-e1d9ac0787e6)

As you can see input buffer starts with some sort of header which holds information about data which follows that header. Basically the input buffer can be divided into three structures:
-Header. It contains information which dispatch function should be called (I described that earlier). It also contains sizes of two next structures and few other irrelevant values. The header can be represented by following struct:

```c
//sizeof(TrufosHeader) = 0x1E
struct TrufosHeader
{
    //Indicates which dispatch function will be called, in this exploit case it should be equal to 0xC
    DWORD FunctionCode;
    //I dont know what it is, but it can't be equal 0 and 6
    DWROD Idk;
    char Padding[0x12];
    unsigned __int16 SizeOfData1;
    unsigned __int16 SizeOfData2;
}
```
-Data1 and Data2 can hold any data, sizes of these structures are contained in header.
Additionally I need to mention that SizeOfData1 + SizeOfData2 + 0x20 must be equal to input buffer length.
I named function in which that pool overflow occurs VulnerableFunction and I will later refer to that function by this name. So first what does this function is check if sizes of data +  0x20 is equal to input buffer length, I marked this in red on next figure. Next it does some checks on second integer (Idk member of TrufosHeader) of input buffer, I don’t know what it is, I just set it to 1 to pass all that checks. Note that SizeOfData1 is at offset 0x1A and SizeOfData2 is at offset 0x1C of input buffer. Next it gets SizeOfData1 and allocates buffer in non paged pool nx of that size (there is some check with SomeGlobalVariable, but this global variable is always set to 0, so it will always allocate that memory using ExAllocatePoolWithTag). After that, it will copy there Data1. Next it will do the same for Data2. So by knowing that Input buffer resides in user address space, can you spot a pool overflow in this code? :)

![6_3](https://github.com/Amunius/TrufosExploit/assets/81387886/bd5c392b-5415-47bf-9f33-8489c6453352)

There are many fetches of data sizes, and since input buffer resides in user address space, these values can be changed by user mode process. For example, I marked with green every fetch of SizeOfData2. By knowing that this value can be changed after allocating pool and before copying memory we are able to cause buffer overflow :D
There is really small time window between allocating and copying these buffers, but it is possible to write really reliable exploit for this vulnerability. The easiest way which I found to reliable trigger this vulnerability is following:
Set SizeOfData1 to zero, Data1 is not needed, Data2 will be used to overflow pool. Allocation buffer of 0 bytes size is possible and ExAllocatePoolWithTag will return valid pointer. Of course copying 0 bytes will do nothing.
Create a thread which will be changing SizeOfData2 very fast so there will be a chance that it will copy bigger buffer to smaller allocated buffer. Usually to trigger this buffer overflow it takes dozen of calls of VulnerableFunction.
So lets examine following scenario:
SizeOfData2 is 0x50, SizeOfData1 is 0, so input buffer length must be 0x70 (0x50 + 0x20). Assuming we want to overflow another 0x50 bytes after allocated buffer, then we need to really fast changing SizeOfData2 to 0xA0 and back to 0x50. In order to do so my exploit creates another thread which is responsible for flipping that value, while main thread calls FilterSendMessage.
By doing this it is possible to overflow buffer with controlled data and size. 
What to do next is rather easy to determine, since exploitation of non paged pool nx is really well researched topic, then I just won’t repeat other great papers. To achieve relative and arbitrary read and then next arbitrary write I used named pipes which internally uses DATA_QUEUE_ENTRY undocumented structure which are useful to achieve such primitives.
If you want to read more about exploiting vulnerabilities in non paged pool nx by using named pipes, I recommend you to read these amazing papers:
- https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation
- https://github.com/vportal/HEVD


Moreover I wouldn’t made this exploit without reading these great papers:
- https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf – here is great explanation about heap in windows kernel
- https://itm4n.github.io/debugging-protected-processes/
- https://j00ru.vexillium.org/2013/06/kernel-double-fetch-race-condition-exploitation-on-x86-further-thoughts/ - very interesting paper about kernel double fetches

At the end I just want to mention, if you want to learn about kernel exploitation or you are just looking for administrator to kernel vulnerabilities, this driver is great place to look for. This is not the only one buffer overflow in Trufos.sys ;)

Note: I reported this buffer overflow two times to bitdefender, but every time I got response that it is not security vulnerability since “if you have administrative rights, you can do anything to a system”. I know that according to microsoft admin-to-kernel is not security boundary, but such vulnerabilities makes a lot of things easier for attackers, so I think such vulnerabilities should be fixed anyway, but that’s only my opinion ¯\\\_(ツ)\_/¯

I made this exploit only for fun and learning purposes.

![ProtectionDisabled](https://github.com/Amunius/TrufosExploit/assets/81387886/101e4945-8135-48e4-9095-9665624dd10d)
